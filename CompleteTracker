import cv2
import numpy as np
import pyfirmata2
import time

# === CONFIGURACIÓN ===
PORT = "COM5"
SERVO_X_PIN = 9
SERVO_Y_PIN = 10
offset_x = 110   # desde calibración
offset_y = 82
Kp_x = 0.12
Kp_y = 0.12
deadband = 8
scale_template = 0.4
thresh_match = 0.6

# === CONEXIÓN ARDUINO ===
board = pyfirmata2.Arduino(PORT)
servo_x = board.get_pin(f'd:{SERVO_X_PIN}:s')
servo_y = board.get_pin(f'd:{SERVO_Y_PIN}:s')

# posiciones iniciales
servo_x_deg = offset_x
servo_y_deg = offset_y
servo_x.write(servo_x_deg)
servo_y.write(servo_y_deg)
print(f"Servo inicial -> Pan: {servo_x_deg}°, Tilt: {servo_y_deg}°")

# === CARGA PLANTILLA OBJETO ===
template = cv2.imread("C:\\Users\\aabm7\\Downloads\\Cartera.jpg", 0)
template = cv2.resize(template, (0,0), fx=scale_template, fy=scale_template)
h, w = template.shape[:2]

# === INICIALIZAR CÁMARA ===
cap = cv2.VideoCapture(0)
cap.set(3, 1280)
cap.set(4, 720)
cv2.namedWindow("AutoControl", cv2.WINDOW_NORMAL)
cv2.resizeWindow("AutoControl", 640, 360)

def detectar_objeto(frame_gray):
    res = cv2.matchTemplate(frame_gray, template, cv2.TM_CCOEFF_NORMED)
    _, max_val, _, max_loc = cv2.minMaxLoc(res)
    if max_val >= thresh_match:
        x, y = max_loc
        cx, cy = x + w//2, y + h//2
        return True, (cx, cy)
    return False, None

def detectar_laser(frame):
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    lower1 = np.array([0, 120, 150])
    upper1 = np.array([10, 255, 255])
    lower2 = np.array([160, 120, 150])
    upper2 = np.array([179, 255, 255])
    mask = cv2.inRange(hsv, lower1, upper1) + cv2.inRange(hsv, lower2, upper2)
    mask = cv2.GaussianBlur(mask, (9,9), 0)
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if contours:
        c = max(contours, key=cv2.contourArea)
        if cv2.contourArea(c) > 5:
            (x, y), _ = cv2.minEnclosingCircle(c)
            return True, (int(x), int(y))
    return False, None

def actualizar_servos(dx, dy):
    global servo_x_deg, servo_y_deg
    if abs(dx) < deadband: dx = 0
    if abs(dy) < deadband: dy = 0

    servo_x_deg += Kp_x * dx
    servo_y_deg += Kp_y * dy  # invertido: en imagen Y crece hacia abajo

    servo_x_deg = max(0, min(180, servo_x_deg))
    servo_y_deg = max(0, min(180, servo_y_deg))

    servo_x.write(servo_x_deg)
    servo_y.write(servo_y_deg)
    return servo_x_deg, servo_y_deg

while True:
    ret, frame = cap.read()
    if not ret:
        break
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    obj_ok, obj_c = detectar_objeto(gray)
    laser_ok, las_c = detectar_laser(frame)

    if obj_ok:
        cv2.circle(frame, obj_c, 5, (0,255,0), -1)
    if laser_ok:
        cv2.circle(frame, las_c, 5, (0,0,255), -1)

    if obj_ok and laser_ok:
        dx = obj_c[0] - las_c[0]
        dy = obj_c[1] - las_c[1]
        cv2.line(frame, obj_c, las_c, (255,255,0), 2)
        cv2.putText(frame, f"Δx={dx:+d} Δy={dy:+d}", (50,50),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255,255,0), 2)
        servo_x_deg, servo_y_deg = actualizar_servos(dx, dy)
        cv2.putText(frame, f"Pan={servo_x_deg:.1f} Tilt={servo_y_deg:.1f}",
                    (50,90), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,255,255), 2)
    else:
        msg = "WAITING LASER" if obj_ok else "WAITING OBJECT"
        cv2.putText(frame, msg, (50,50), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0,0,255), 2)

    cv2.imshow("AutoControl", frame)
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
board.exit()
cv2.destroyAllWindows()
