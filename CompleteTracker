import cv2
import numpy as np
import pyfirmata2
import time

# === CONFIGURACIÓN ===
PORT = "COM5"
SERVO_X_PIN = 9
SERVO_Y_PIN = 10

# Calibración base
offset_x = 42
offset_y = 2
Kp_x = 0.25
Kp_y = 0.25
deadband = 8

# Relación píxel → grados aproximada
deg_per_px_x = 0.047
deg_per_px_y = 0.055

# === CONEXIÓN ARDUINO ===
board = pyfirmata2.Arduino(PORT)
servo_x = board.get_pin(f'd:{SERVO_X_PIN}:s')
servo_y = board.get_pin(f'd:{SERVO_Y_PIN}:s')

# Movimiento inicial suave
def mover_suavemente(servo, actual, objetivo, paso=1, delay=0.02):
    if objetivo > actual:
        rango = range(int(actual), int(objetivo) + 1, paso)
    else:
        rango = range(int(actual), int(objetivo) - 1, -paso)
    for a in rango:
        servo.write(a)
        time.sleep(delay)
    return objetivo

print("🟡 Moviendo a posición de calibración lenta...")
servo_x_deg = mover_suavemente(servo_x, 90, offset_x, paso=1, delay=0.02)
servo_y_deg = mover_suavemente(servo_y, 90, offset_y, paso=1, delay=0.02)
print(f"✅ Servos listos -> Pan: {servo_x_deg}°, Tilt: {servo_y_deg}°")

# === TEMPLATE DEL OBJETO ===
template = cv2.imread("C:\\Users\\aabm7\\Downloads\\Cartera.jpg", 0)
if template is None:
    raise FileNotFoundError("No se encontró la imagen de la cartera.")

# Escalado adaptativo para evitar error
def escalar_template(template, frame_shape):
    hF, wF = frame_shape[:2]
    hT, wT = template.shape[:2]
    if hT > hF or wT > wF:
        scale = min(wF / wT, hF / hT) * 0.4
        template = cv2.resize(template, (0, 0), fx=scale, fy=scale)
    else:
        template = cv2.resize(template, (0, 0), fx=0.4, fy=0.4)
    return template

h, w = template.shape[:2]

# === CÁMARA ===
cap = cv2.VideoCapture(0)
cap.set(3, 1280)
cap.set(4, 720)
cv2.namedWindow("DeltaVisual", cv2.WINDOW_NORMAL)
cv2.resizeWindow("DeltaVisual", 640, 360)

# === FILTRO KALMAN ===
kalman = cv2.KalmanFilter(4, 2)
kalman.measurementMatrix = np.array([[1, 0, 0, 0],
                                     [0, 1, 0, 0]], np.float32)
kalman.transitionMatrix = np.array([[1, 0, 1, 0],
                                    [0, 1, 0, 1],
                                    [0, 0, 1, 0],
                                    [0, 0, 0, 1]], np.float32)
kalman.processNoiseCov = np.eye(4, dtype=np.float32) * 0.01
kalman.measurementNoiseCov = np.eye(2, dtype=np.float32) * 1.5
kalman.statePre = np.zeros((4, 1), np.float32)
kalman.statePost = np.zeros((4, 1), np.float32)
kalman_initialized = False

# === DETECCIÓN ===
def detectar_objeto(frame_gray):
    global template, h, w
    if template.shape[0] > frame_gray.shape[0] or template.shape[1] > frame_gray.shape[1]:
        template = escalar_template(template, frame_gray.shape)
        h, w = template.shape[:2]

    res = cv2.matchTemplate(frame_gray, template, cv2.TM_CCOEFF_NORMED)
    _, max_val, _, max_loc = cv2.minMaxLoc(res)
    if max_val >= 0.4:
        x, y = max_loc
        cx, cy = x + w // 2, y + h // 2
        return True, (cx, cy)
    return False, None

def detectar_laser(frame):
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    lower1 = np.array([0, 120, 150])
    upper1 = np.array([10, 255, 255])
    lower2 = np.array([160, 120, 150])
    upper2 = np.array([179, 255, 255])
    mask = cv2.inRange(hsv, lower1, upper1) + cv2.inRange(hsv, lower2, upper2)
    mask = cv2.GaussianBlur(mask, (9, 9), 0)
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if contours:
        c = max(contours, key=cv2.contourArea)
        if cv2.contourArea(c) > 5:
            (x, y), _ = cv2.minEnclosingCircle(c)
            return True, (int(x), int(y))
    return False, None

# === CONTROL ===
def actualizar_servos(dx, dy):
    global servo_x_deg, servo_y_deg

    if abs(dx) < deadband: dx = 0
    if abs(dy) < deadband: dy = 0

    delta_x = Kp_x * dx * deg_per_px_x
    delta_y = Kp_y * dy * deg_per_px_y

    servo_x_deg -= delta_x
    servo_y_deg -= delta_y  # sin invertir tu eje

    servo_x_deg = float(np.clip(servo_x_deg, 0, 180))
    servo_y_deg = float(np.clip(servo_y_deg, 0, 180))

    servo_x.write(servo_x_deg)
    servo_y.write(servo_y_deg)

    return servo_x_deg, servo_y_deg


# === LOOP PRINCIPAL ===
while True:
    ret, frame = cap.read()
    if not ret:
        break

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    obj_ok, obj_c = detectar_objeto(gray)
    laser_ok, las_c = detectar_laser(frame)

    # --- KALMAN ---
    if obj_ok:
        measurement = np.array([[np.float32(obj_c[0])],
                                [np.float32(obj_c[1])]])
        if not kalman_initialized:
            kalman.statePost[:2, 0] = measurement[:, 0]
            kalman_initialized = True
        kalman.correct(measurement)

    predicted = kalman.predict()
    pred_x, pred_y = int(float(predicted[0][0])), int(float(predicted[1][0]))

    cv2.circle(frame, (pred_x, pred_y), 5, (0, 255, 255), -1)
    cv2.putText(frame, "KALMAN", (pred_x + 10, pred_y),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)

    # --- VISUALIZACIÓN ---
    if obj_ok:
        cv2.circle(frame, obj_c, 5, (0, 255, 0), -1)
    if laser_ok:
        cv2.circle(frame, las_c, 5, (0, 0, 255), -1)

    if laser_ok and kalman_initialized:
        dx = pred_x - las_c[0]
        dy = pred_y - las_c[1]
        cv2.line(frame, las_c, (pred_x, pred_y), (255, 255, 0), 2)
        cv2.putText(frame, f"DELTA ({dx:+d}, {dy:+d})", (50, 50),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 0), 2)
        servo_x_deg, servo_y_deg = actualizar_servos(dx, dy)
        cv2.putText(frame, "TRACKING", (50, 90),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 255), 2)
    else:
        msg = "WAITING LASER" if obj_ok else "WAITING OBJECT"
        cv2.putText(frame, msg, (50, 50),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)

    cv2.imshow("DeltaVisual", frame)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
board.exit()
cv2.destroyAllWindows()
